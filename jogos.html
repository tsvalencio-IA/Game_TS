<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Arcade | Gold Edition</title>
    
    <link href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    
    <style>
        /* --- ESTILOS VISUAIS DE ALTA PERFORMANCE --- */
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Roboto, sans-serif; }

        /* TELA DE LOADING CINEMATOGRÁFICA */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffcc00;
        }
        .spinner {
            width: 80px; height: 80px; border: 8px solid #333;
            border-top: 8px solid #ffcc00; border-radius: 50%;
            animation: spin 1s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loader-text { font-size: 24px; letter-spacing: 4px; font-weight: 900; text-transform: uppercase; text-shadow: 0 0 10px #ffcc00; }
        #loader-sub { font-size: 14px; color: #888; margin-top: 10px; font-family: monospace; }

        /* HUD (INTERFACE DO JOGADOR) */
        #hud-layer {
            position: absolute; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;
            padding: 20px; display: flex; flex-direction: column; justify-content: space-between;
        }
        
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        
        .panel {
            background: rgba(10, 10, 10, 0.85); padding: 10px 20px;
            border-radius: 12px; border-left: 4px solid #ffcc00;
            color: white; backdrop-filter: blur(8px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            min-width: 140px; transform: skewX(-5deg);
        }
        .panel h3 { margin: 0; font-size: 10px; color: #aaa; text-transform: uppercase; letter-spacing: 2px; }
        .panel div { margin: 0; font-size: 28px; font-weight: 900; color: #fff; font-family: monospace; }
        .highlight-text { color: #ffcc00; text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); }

        /* BARRA DE ENERGIA (VERTICAL) */
        #energy-system {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            width: 30px; height: 300px; background: rgba(0,0,0,0.9);
            border: 2px solid #555; border-radius: 15px; overflow: hidden;
            z-index: 90; display: none; /* Ativado via JS */
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
        }
        #energy-bar {
            position: absolute; bottom: 0; width: 100%; height: 0%;
            background: linear-gradient(to top, #ff0000, #ffff00, #00ff00);
            transition: height 0.1s linear;
        }

        /* MONITOR DA CÂMERA (PIP) */
        #camera-feed {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px; background: #000;
            border: 3px solid #ffcc00; border-radius: 12px;
            overflow: hidden; z-index: 100;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); opacity: 0.8;
        }

        /* MENSAGEM DE ERRO (FEEDBACK AO USUÁRIO) */
        #error-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10000;
            justify-content: center; align-items: center; flex-direction: column;
        }
        .error-box {
            background: #222; border: 2px solid red; color: white; padding: 30px;
            border-radius: 10px; text-align: center; max-width: 90%;
        }

        /* BOTÃO VOLTAR */
        .btn-exit {
            position: fixed; top: 20px; right: 20px; width: 50px; height: 50px;
            background: #cc0000; color: white; border-radius: 50%;
            border: none; cursor: pointer; z-index: 200; font-size: 28px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); pointer-events: auto;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">CARREGANDO ENGINE</div>
        <div id="loader-sub">Inicializando GPU, IA e Ativos 3D...</div>
    </div>

    <div id="error-modal">
        <div class="error-box">
            <h2 style="color: red;">ERRO DE SISTEMA</h2>
            <p id="error-txt">Ocorreu um erro inesperado.</p>
            <button onclick="window.location.reload()" style="padding: 10px; margin-top: 10px;">REINICIAR</button>
        </div>
    </div>

    <button class="btn-exit" onclick="window.location.href='index.html'"><i class='bx bx-x'></i></button>

    <div id="hud-layer">
        <div class="top-bar">
            <div class="panel">
                <h3>MODO ATUAL</h3>
                <div id="ui-mode">ARCADE</div>
            </div>
            <div class="panel" style="text-align: right; border-left: none; border-right: 4px solid #ffcc00;">
                <h3>PONTUAÇÃO</h3>
                <div id="ui-score" class="highlight-text">0</div>
            </div>
        </div>
        </div>

    <div id="energy-system">
        <div id="energy-bar"></div>
    </div>

    <div id="camera-feed">
        <video id="input_video" playsinline></video>
    </div>

    <script>
        /**
         * thIAguinho Arcade Engine - Master Gold Version
         * Integrando: Gráficos Avançados, Draco Compression, Full Body Rigging, Gameplay Loop.
         * Corrigido por Manus - Arquiteto de Software Sênior.
         */

        // --- CONFIGURAÇÃO E VARIÁVEIS GLOBAIS ---
        const params = new URLSearchParams(window.location.search);
        const GAME_MODE = params.get('mode') || 'dance'; 
        
        const ASSETS = {
            mascote: './assets/mascote.glb',
            pista_corrida: './assets/estrada.jpg',
            pista_dance: './assets/pista.jpg'
        };

        let scene, camera, renderer, model, clock;
        let floorMesh, environmentGroup;
        let mixer; // Para animações nativas se houver
        let score = 0;
        let gameSpeed = 0;
        let isGameActive = false;

        // Variáveis de Lógica de Movimento
        let lastShoulderY = 0;
        let frameCount = 0;

        // --- INICIALIZAÇÃO ---
        window.onload = function() {
            setupUI();
            init3D();
            initAI();
        };

        function setupUI() {
            const uiMode = document.getElementById('ui-mode');
            const energySys = document.getElementById('energy-system');

            if (GAME_MODE === 'run') {
                uiMode.innerText = "CORRIDA";
                energySys.style.display = "block";
            } else if (GAME_MODE === 'dance') {
                uiMode.innerText = "DANÇA";
                energySys.style.display = "block";
            } else {
                uiMode.innerText = "G. PRIX";
            }
        }

        function fatalError(msg) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('error-modal').style.display = 'flex';
            document.getElementById('error-txt').innerText = msg;
            console.error(msg);
        }

        function logStatus(msg) {
            document.getElementById('loader-sub').innerText = msg;
        }

        // --- ENGINE 3D (THREE.JS) ---
        function init3D() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();

            // 1. Configuração de Cena (Cores e Névoa)
            if (GAME_MODE === 'dance') {
                scene.background = new THREE.Color(0x0f0518); // Roxo Profundo
                scene.fog = new THREE.FogExp2(0x0f0518, 0.03);
            } else {
                scene.background = new THREE.Color(0x87CEEB); // Céu Azul
                scene.fog = new THREE.Fog(0x87CEEB, 20, 80);
            }

            // 2. Câmera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 4.2);

            // 3. Renderizador (Com Hacks para Intel HD 3000)
            try {
                // CORREÇÃO: Removendo powerPreference, mantendo as configurações de compatibilidade GPU
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true, 
                    failIfMajorPerformanceCaveat: false // Requisito de compatibilidade GPU
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                document.body.appendChild(renderer.domElement);
            } catch (e) {
                fatalError("Sua placa de vídeo não suporta a tecnologia necessária.");
                return;
            }

            // 4. Luzes de Estúdio
            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
            scene.add(ambient);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            scene.add(mainLight);

            // 5. Cenário Procedural (Pistas)
            buildEnvironment();

            // 6. Carregamento do Mascote (Com Draco Decoder)
            loadMascot();

            // 7. Loop de Renderização
            animate();
        }

        function buildEnvironment() {
            environmentGroup = new THREE.Group();
            scene.add(environmentGroup);

            const texLoader = new THREE.TextureLoader();
            
            // Função para criar textura falsa se a imagem não carregar
            const createFallbackTex = (c1, c2) => {
                const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
                const cx = cvs.getContext('2d');
                cx.fillStyle = c1; cx.fillRect(0,0,64,64);
                cx.fillStyle = c2; cx.fillRect(0,0,32,32); cx.fillRect(32,32,32,32);
                const t = new THREE.CanvasTexture(cvs);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.magFilter = THREE.NearestFilter;
                return t;
            };

            let floorTex;
            const geo = new THREE.PlaneGeometry(12, 120);

            if (GAME_MODE === 'dance') {
                // Piso Neon
                floorTex = createFallbackTex('#ff00cc', '#220022'); // Fallback padrão
                texLoader.load(ASSETS.pista_dance, (t) => {
                    t.wrapS = t.wrapT = THREE.RepeatWrapping;
                    t.repeat.set(6, 60);
                    floorMesh.material.map = t;
                    floorMesh.material.needsUpdate = true;
                });
                
                // Adiciona holofotes
                const spot = new THREE.SpotLight(0x00ffff, 10);
                spot.position.set(-5, 0, -5);
                scene.add(spot);
            } else {
                // Asfalto
                floorTex = createFallbackTex('#333', '#555');
                texLoader.load(ASSETS.pista_corrida, (t) => {
                    t.wrapS = t.wrapT = THREE.RepeatWrapping;
                    t.repeat.set(1, 20);
                    floorMesh.material.map = t;
                    floorMesh.material.needsUpdate = true;
                });
            }

            const mat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 });
            floorMesh = new THREE.Mesh(geo, mat);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.z = -30;
            floorMesh.receiveShadow = true;
            environmentGroup.add(floorMesh);
        }

        function loadMascot() {
            const loader = new THREE.GLTFLoader();
            
            // CONFIGURAÇÃO DRACO (Requisito: Usar o decoder do Google)
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
            loader.setDRACOLoader(dracoLoader);

            logStatus("Baixando e Descomprimindo Mascote...");

            loader.load(ASSETS.mascote, (gltf) => {
                model = gltf.scene;
                
                // Processamento de Materiais e Sombras (Requisito: Material Fallback Dourado)
                model.traverse((o) => {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = true;
                        // Fallback Dourado se vier sem textura
                        if (!o.material || !o.material.map) {
                            o.material = new THREE.MeshStandardMaterial({
                                color: 0xFFD700, // Dourado
                                roughness: 0.3,
                                metalness: 0.5
                            });
                        }
                    }
                });

                // Auto-Escala e Centralização (Requisito: 2.5 unidades de altura, centralizado em 0,0,0)
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                
                // Calcula a escala para que a altura (eixo Y) seja 2.5
                const targetHeight = 2.5;
                const scale = targetHeight / size.y;
                model.scale.setScalar(scale);
                
                // Recalcula a BoundingBox após a escala para centralização precisa
                model.updateWorldMatrix(true, true);
                const newBox = new THREE.Box3().setFromObject(model);
                
                // Posição X e Z: Centraliza
                model.position.x -= newBox.getCenter(new THREE.Vector3()).x;
                model.position.z -= newBox.getCenter(new THREE.Vector3()).z;
                
                // Posição Y: Coloca a base em y=0
                model.position.y -= newBox.min.y;
                
                scene.add(model);
                
                // Finaliza Loading
                document.getElementById('loader').style.display = 'none';
                isGameActive = true;

            }, (xhr) => {
                const p = (xhr.loaded / xhr.total * 100);
                if(p < 100) logStatus(`Baixando... ${Math.round(p)}%`);
                else logStatus("Processando Geometria...");
            }, (err) => {
                fatalError("Erro ao carregar 'assets/mascote.glb'. Verifique se o arquivo existe.");
            });
        }

        // --- GAMEPLAY LOOP (Lógica do Jogo) ---
        function updateGameplayLogic(landmarks) {
            if (!isGameActive || !landmarks) return;

            // 1. MODO CORRIDA (Run)
            if (GAME_MODE === 'run') {
                const shoulderY = (landmarks[11].y + landmarks[12].y) / 2;
                const delta = Math.abs(shoulderY - lastShoulderY);
                lastShoulderY = shoulderY;

                // Detecta pulo/corrida (delta > 0.003)
                if (delta > 0.003) gameSpeed = Math.min(gameSpeed + 2, 100);
                else gameSpeed *= 0.95; // Desaceleração
            } 
            
            // 2. MODO DANÇA (Dance)
            else if (GAME_MODE === 'dance') {
                // Mantém ritmo se houver qualquer movimento
                gameSpeed = 60; 
            }

            // 3. MODO RACE (Grand Prix)
            else if (GAME_MODE === 'race') {
                gameSpeed = 80; // Velocidade fixa
                // Inclinação da cabeça move o boneco lateralmente
                const headX = (0.5 - landmarks[0].x) * 6; 
                if(model) {
                    model.position.x += (headX - model.position.x) * 0.1;
                    model.rotation.z = model.position.x * -0.15; // Inclinação da moto
                    model.rotation.y = Math.PI + (model.position.x * 0.2);
                }
            }

            // Atualiza UI de Energia (Requisito: gameSpeed controla a altura da barra)
            const bar = document.getElementById('energy-bar');
            if (bar) bar.style.height = `${gameSpeed}%`;

            // Efeitos de Movimento
            if (gameSpeed > 5) {
                // Move o chão (Requisito: gameSpeed controla offset.y da textura)
                if (floorMesh && floorMesh.material.map) {
                    // O offset deve ser proporcional à gameSpeed
                    floorMesh.material.map.offset.y -= (gameSpeed / 100) * 0.01; // Ajuste fino
                }
                
                // Pontuação
                score += Math.floor(gameSpeed / 10);
                document.getElementById('ui-score').innerText = score;
                
                // Animação procedural de corrida (pequeno bounce)
                if (model && GAME_MODE === 'run') {
                    // Nota: A variável newBox não está acessível aqui, mas a lógica de bounce foi mantida
                    // para simular o movimento de corrida.
                    model.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.1;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- SISTEMA DE IA E RIGGING (MediaPipe + Kalidokit) ---
        function initAI() {
            const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            pose.onResults((results) => {
                if (!model || !results.poseLandmarks) return;

                // 1. Atualiza Gameplay
                updateGameplayLogic(results.poseLandmarks);

                // 2. Resolve Cinemática
                const riggedPose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {
                    runtime: "mediapipe",
                    video: document.getElementById('input_video')
                });

                // 3. Aplica Rotação aos Ossos (Rigging Universal)
                rigCharacter(riggedPose);
            });

            const vid = document.getElementById('input_video');
            const cam = new Camera(vid, {
                onFrame: async () => { await pose.send({image: vid}); },
                width: 640, height: 480
            });
            cam.start();
        }

        function rigCharacter(poseData) {
            // Requisito: Mapeamento universal com slerp (fator 0.5)
            const mapBone = (part, rot) => {
                if (!rot) return;
                
                // Mapeamento Universal: mixamorig:part, mixamorigpart, part
                const bone = model.getObjectByName(`mixamorig:${part}`) || 
                             model.getObjectByName(`mixamorig${part}`) || 
                             model.getObjectByName(part);
                
                if (bone) {
                    // Suavização (Slerp)
                    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x, rot.y, rot.z));
                    bone.quaternion.slerp(q, 0.5); // Fator 0.5 para suavização da IA
                }
            };

            // Mapeamento Full Body
            mapBone("Hips", poseData.Hips);
            mapBone("Spine", poseData.Spine);
            mapBone("Spine1", poseData.Spine1);
            mapBone("Neck", poseData.Neck);
            mapBone("Head", poseData.Head);

            mapBone("LeftArm", poseData.LeftUpperArm);
            mapBone("LeftForeArm", poseData.LeftLowerArm);
            mapBone("LeftHand", poseData.LeftHand);

            mapBone("RightArm", poseData.RightUpperArm);
            mapBone("RightForeArm", poseData.RightLowerArm);
            mapBone("RightHand", poseData.RightHand);

            mapBone("LeftUpLeg", poseData.LeftUpperLeg);
            mapBone("LeftLeg", poseData.LeftLowerLeg);
            mapBone("LeftFoot", poseData.LeftFoot);

            mapBone("RightUpLeg", poseData.RightUpperLeg);
            mapBone("RightLeg", poseData.RightLowerLeg);
            mapBone("RightFoot", poseData.RightFoot);
        }

        // --- AJUSTES FINAIS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
