<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Arcade | Master Engine</title>
    
    <link href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }

        /* TELA DE CARREGAMENTO */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffcc00;
        }
        .spinner {
            width: 70px; height: 70px; border: 8px solid #333;
            border-top: 8px solid #ffcc00; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loader-text { font-size: 18px; letter-spacing: 2px; font-weight: bold; text-transform: uppercase; }
        #loader-sub { font-size: 12px; color: #666; margin-top: 5px; }

        /* HUD SUPERIOR (PONTOS E STATUS) */
        #hud {
            position: absolute; top: 0; width: 100%; padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 100; pointer-events: none;
        }
        .panel {
            background: rgba(0, 0, 0, 0.85); padding: 10px 20px;
            border-radius: 12px; border-bottom: 4px solid #ffcc00;
            color: white; backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            min-width: 120px;
        }
        .panel-label { font-size: 10px; color: #aaa; letter-spacing: 1px; margin-bottom: 2px; }
        .panel-val { font-size: 24px; font-weight: 800; color: #fff; font-family: monospace; }
        .highlight { color: #ffcc00; }

        /* BARRA DE ENERGIA LATERAL */
        #energy-container {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            width: 25px; height: 250px; background: rgba(0,0,0,0.8);
            border: 2px solid #555; border-radius: 15px; overflow: hidden;
            z-index: 90; display: none; /* Ativo apenas em gameplay */
        }
        #energy-fill {
            position: absolute; bottom: 0; width: 100%; height: 0%;
            background: linear-gradient(to top, #ff0000, #ffff00, #00ff00);
            transition: height 0.1s linear;
        }

        /* MONITOR DA CÂMERA (CANTO INFERIOR) */
        #cam-monitor {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px; background: #000;
            border: 3px solid #ffcc00; border-radius: 12px;
            overflow: hidden; z-index: 100;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.2);
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* Espelhar câmera */
            opacity: 0.9;
        }

        /* BOTÃO SAIR */
        .btn-exit {
            position: fixed; top: 20px; right: 20px; width: 45px; height: 45px;
            background: #cc0000; color: white; border-radius: 50%;
            border: none; cursor: pointer; z-index: 200; font-size: 24px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn-exit:active { transform: scale(0.9); }

        /* MENSAGEM DE ERRO (DEBUG) */
        #error-msg {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(200, 0, 0, 0.9);
            color: white; padding: 20px; border-radius: 10px; z-index: 10000;
            text-align: center; max-width: 80%;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">CARREGANDO ENGINE</div>
        <div id="loader-sub">Inicializando GPU e IA...</div>
    </div>

    <div id="error-msg"></div>

    <button class="btn-exit" onclick="window.location.href='index.html'"><i class='bx bx-log-out'></i></button>

    <div id="hud">
        <div class="panel">
            <div class="panel-label">MODO DE JOGO</div>
            <div id="ui-mode" class="panel-val">ARCADE</div>
        </div>
        <div class="panel" style="text-align: right;">
            <div class="panel-label">PONTUAÇÃO</div>
            <div id="ui-score" class="panel-val highlight">0</div>
        </div>
    </div>

    <div id="energy-container">
        <div id="energy-fill"></div>
    </div>

    <div id="cam-monitor">
        <video id="input_video" playsinline></video>
    </div>

    <script>
        // --- CONFIGURAÇÃO GLOBAL ---
        const params = new URLSearchParams(window.location.search);
        const GAME_MODE = params.get('mode') || 'dance'; // dance, run, race
        const ASSETS = {
            mascote: './assets/mascote.glb',
            pista_corrida: './assets/estrada.jpg',
            pista_dance: './assets/pista.jpg'
        };

        // VARIÁVEIS DE ESTADO
        let scene, camera, renderer, model, clock;
        let mixer; // Para animações se houver
        let floorMesh, environmentGroup;
        let isLoaded = false;
        let score = 0;
        let speed = 0;
        
        // Variáveis de Gameplay
        let lastShoulderY = 0; // Para detectar corrida
        let headPositionX = 0; // Para detectar inclinação
        let energyLevel = 0; // Para dança

        // --- SISTEMA DE INICIALIZAÇÃO ---
        window.onload = function() {
            updateUI();
            init3D();
            initAI();
        };

        function updateUI() {
            const label = document.getElementById('ui-mode');
            const energy = document.getElementById('energy-container');
            
            if (GAME_MODE === 'run') {
                label.innerText = "CORRIDA";
                energy.style.display = 'block';
            } else if (GAME_MODE === 'dance') {
                label.innerText = "DANÇA";
                energy.style.display = 'block';
            } else if (GAME_MODE === 'race') {
                label.innerText = "G. PRIX";
            }
        }

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.innerText = msg;
            el.style.display = 'block';
            document.getElementById('loader').style.display = 'none';
        }

        // --- MOTOR GRÁFICO (THREE.JS) ---
        function init3D() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();

            // 1. Configuração de Cena (Ambiente)
            if (GAME_MODE === 'dance') {
                scene.background = new THREE.Color(0x0a001a); // Roxo escuro
                scene.fog = new THREE.FogExp2(0x0a001a, 0.02);
            } else {
                scene.background = new THREE.Color(0x87CEEB); // Céu azul
                scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            }

            // 2. Câmera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 4.5); // Altura dos olhos, afastada

            // 3. Renderizador (Com Fix Intel HD)
            try {
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true, 
                    failIfMajorPerformanceCaveat: false, // OBRIGATÓRIO PARA SUA PLACA
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true; // Sombras reais
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                document.body.appendChild(renderer.domElement);
            } catch (e) {
                showError("ERRO FATAL: Sua placa de vídeo não suporta WebGL 3D.");
                return;
            }

            // 4. Luzes (Estúdio Profissional)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // 5. Criação do Cenário (Chão Infinito)
            createEnvironment();

            // 6. Carregamento do Mascote
            loadMascot();

            // 7. Iniciar Loop
            animate();
        }

        function createEnvironment() {
            environmentGroup = new THREE.Group();
            scene.add(environmentGroup);

            const texLoader = new THREE.TextureLoader();
            
            // Função auxiliar para gerar textura se a imagem falhar
            const createFallbackTexture = (color1, color2) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color1; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = color2; ctx.fillRect(0,0,32,32); ctx.fillRect(32,32,32,32);
                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                tex.magFilter = THREE.NearestFilter;
                return tex;
            };

            let floorTex;
            if (GAME_MODE === 'dance') {
                // Piso de Balada
                try {
                    floorTex = texLoader.load(ASSETS.pista_dance, null, null, () => {
                        console.warn("Textura pista não encontrada, usando gerada.");
                        floorMesh.material.map = createFallbackTexture('#ff00cc', '#330033');
                        floorMesh.material.needsUpdate = true;
                    });
                } catch(e) { floorTex = createFallbackTexture('#ff00cc', '#330033'); }
                
                floorTex.wrapS = THREE.RepeatWrapping;
                floorTex.wrapT = THREE.RepeatWrapping;
                floorTex.repeat.set(10, 10);
                
                // Adiciona Luzes de Neon
                const spot = new THREE.SpotLight(0x00ffff, 5);
                spot.position.set(-5, 0, -5);
                scene.add(spot);

            } else {
                // Estrada
                try {
                    floorTex = texLoader.load(ASSETS.pista_corrida, null, null, () => {
                        console.warn("Textura estrada não encontrada, usando gerada.");
                        floorMesh.material.map = createFallbackTexture('#333333', '#444444');
                        floorMesh.material.needsUpdate = true;
                    });
                } catch(e) { floorTex = createFallbackTexture('#333333', '#444444'); }

                floorTex.wrapS = THREE.RepeatWrapping;
                floorTex.wrapT = THREE.RepeatWrapping;
                floorTex.repeat.set(1, 20); // Estrada longa
            }

            const geo = new THREE.PlaneGeometry(10, 100);
            const mat = new THREE.MeshStandardMaterial({ 
                map: floorTex, 
                roughness: 0.8,
                color: 0xffffff
            });
            
            floorMesh = new THREE.Mesh(geo, mat);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.z = -30; // Começa atrás do boneco
            floorMesh.receiveShadow = true;
            environmentGroup.add(floorMesh);
        }

        function loadMascot() {
            const loader = new THREE.GLTFLoader();
            
            loader.load(ASSETS.mascote, (gltf) => {
                model = gltf.scene;
                
                // --- FIX DE MATERIAIS E SOMBRAS ---
                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        // Se não tiver textura (branco), aplica Dourado thIAguinho
                        if (!node.material.map) {
                            node.material = new THREE.MeshStandardMaterial({
                                color: 0xFFCC00,
                                roughness: 0.4,
                                metalness: 0.3
                            });
                        }
                    }
                });

                // --- NORMALIZAÇÃO DE ESCALA ---
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3()).length();
                if (size > 0) {
                    const scaleFactor = 2.5 / size; // Define altura para ~2.5 unidades
                    model.scale.setScalar(scaleFactor);
                }
                
                // Centralizar
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x * model.scale.x;
                model.position.z = 0;
                model.position.y = 0; // Pés no chão

                scene.add(model);
                
                // Fim do Loading
                isLoaded = true;
                document.getElementById('loader').style.display = 'none';

            }, (xhr) => {
                // Progresso
                let p = (xhr.loaded / xhr.total * 100);
                document.getElementById('loader-sub').innerText = `Baixando Modelo: ${Math.round(p)}%`;
            }, (error) => {
                showError("ERRO: O arquivo 'mascote.glb' não está na pasta 'assets'.");
                console.error(error);
            });
        }

        // --- SISTEMA DE IA E RIGGING (MediaPipe) ---
        function initAI() {
            const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            
            pose.setOptions({
                modelComplexity: 1, // 0=Lite, 1=Full, 2=Heavy
                smoothLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            pose.onResults(onPoseResults);

            const video = document.getElementById('input_video');
            const camera = new Camera(video, {
                onFrame: async () => { await pose.send({image: video}); },
                width: 640, height: 480
            });
            camera.start();
        }

        function onPoseResults(results) {
            if (!model || !results.poseLandmarks) return;

            // 1. Solver Cinemático (Transforma 2D em 3D)
            const riggedPose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {
                runtime: "mediapipe",
                video: document.getElementById('input_video')
            });

            // 2. Mapeamento Robusto (Aceita mixamorig: e mixamorig_)
            rigBody(riggedPose);

            // 3. Lógica de Gameplay
            updateGameplayLogic(results.poseLandmarks);
        }

        function rigBody(poseData) {
            // Função auxiliar para encontrar ossos com nomes variados
            const findBone = (names) => {
                for (let name of names) {
                    const bone = model.getObjectByName(name);
                    if (bone) return bone;
                }
                return null;
            };

            const mapBone = (partName, rotData) => {
                if (!rotData) return;
                
                // Tenta todas as variações de nome comuns
                const bone = findBone([
                    `mixamorig:${partName}`, 
                    `mixamorig${partName}`, 
                    `mixamorig_${partName}`,
                    partName
                ]);

                if (bone) {
                    // Interpolação (Suavização)
                    const targetQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(rotData.x, rotData.y, rotData.z));
                    bone.quaternion.slerp(targetQ, 0.5); // Fator 0.5 de suavização
                }
            };

            // Mapeamento Completo
            mapBone("Hips", poseData.Hips);
            mapBone("Spine", poseData.Spine);
            mapBone("Spine1", poseData.Spine1);
            mapBone("Neck", poseData.Neck);
            mapBone("Head", poseData.Head);

            mapBone("LeftArm", poseData.LeftUpperArm);
            mapBone("LeftForeArm", poseData.LeftLowerArm);
            mapBone("LeftHand", poseData.LeftHand);

            mapBone("RightArm", poseData.RightUpperArm);
            mapBone("RightForeArm", poseData.RightLowerArm);
            mapBone("RightHand", poseData.RightHand);

            mapBone("LeftUpLeg", poseData.LeftUpperLeg);
            mapBone("LeftLeg", poseData.LeftLowerLeg);
            mapBone("LeftFoot", poseData.LeftFoot);

            mapBone("RightUpLeg", poseData.RightUpperLeg);
            mapBone("RightLeg", poseData.RightLowerLeg);
            mapBone("RightFoot", poseData.RightFoot);
        }

        // --- LÓGICA DE PONTUAÇÃO E FÍSICA ---
        function updateGameplayLogic(landmarks) {
            if (!landmarks) return;

            // Modo CORRIDA
            if (GAME_MODE === 'run') {
                const shoulderY = (landmarks[11].y + landmarks[12].y) / 2;
                const delta = Math.abs(shoulderY - lastShoulderY);
                lastShoulderY = shoulderY;

                // Se houver oscilação vertical (corrida)
                if (delta > 0.003) {
                    speed = Math.min(speed + 1, 100);
                } else {
                    speed *= 0.95; // Desacelera
                }
            }

            // Modo DANÇA
            else if (GAME_MODE === 'dance') {
                // Calcula movimento dos pulsos
                // (Simplificado para fins de demo: velocidade constante se detectado)
                speed = 60; 
            }

            // Modo RACE (Grand Prix)
            else if (GAME_MODE === 'race') {
                speed = 80; // Velocidade fixa
                // Inclinação da cabeça controla X
                const noseX = landmarks[0].x; // 0 a 1
                const targetX = (0.5 - noseX) * 5; // Inverte e amplifica
                
                // Move o modelo suavemente
                model.position.x += (targetX - model.position.x) * 0.1;
                // Inclina o modelo para efeito visual
                model.rotation.z = (model.position.x * -0.2);
            }

            // Atualiza UI
            const energyBar = document.getElementById('energy-fill');
            if (energyBar) energyBar.style.height = `${speed}%`;

            if (speed > 5) {
                // Move o chão (efeito de velocidade)
                if (floorMesh && floorMesh.material.map) {
                    floorMesh.material.map.offset.y -= (speed * 0.0005);
                }
                // Ganha pontos
                score += Math.floor(speed / 10);
                document.getElementById('ui-score').innerText = score;
            }
        }

        // --- LOOP DE RENDERIZAÇÃO ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Ajuste de Tela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>