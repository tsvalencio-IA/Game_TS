<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>thIAguinho Arcade Engine | Gameplay Edition</title>
    <link href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    
    <style>
        /* --- ESTILOS VISUAIS DE ALTA PERFORMANCE (Baseado no Gemini) --- */
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* HUD GAMER */
        #hud-top { position: absolute; top: 0; width: 100%; padding: 15px; z-index: 50; display: flex; justify-content: space-between; pointer-events: none; }
        .hud-panel { background: rgba(0,0,0,0.85); padding: 10px 20px; border-radius: 8px; border-bottom: 4px solid #ffcc00; color: #fff; box-shadow: 0 0 15px rgba(255, 204, 0, 0.3); }
        .label { font-size: 10px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        .value { font-size: 28px; font-weight: 900; font-family: monospace; color: #ffcc00; }
        
        /* BARRA DE VELOCIDADE / ENERGIA */
        #energy-bar-container { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: 20px; height: 200px; background: #333; border-radius: 10px; overflow: hidden; border: 2px solid #555; z-index: 50; }
        #energy-fill { width: 100%; height: 0%; background: linear-gradient(to top, #ff0000, #ffcc00, #00ff00); position: absolute; bottom: 0; transition: height 0.2s; }

        /* CAMERA */
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border: 3px solid #ffcc00; border-radius: 12px; overflow: hidden; z-index: 100; background: #000; }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }

        /* LOADING */
        #loading { position: absolute; top: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        .spinner { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #ffcc00; border-radius: 50%; animation: spin 1s infinite; margin-bottom: 20px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .back-btn { position: fixed; top: 20px; right: 20px; z-index: 150; background: #cc0000; color: white; width: 40px; height: 40px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Requisito: DRACOLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
</head>
<body>
    <button onclick="window.location.href='index.html'" class="back-btn"><i class='bx bx-log-out'></i></button>

    <div id="loading">
        <div class="spinner"></div>
        <h2 style="color: #ffcc00;">PREPARANDO ARENA...</h2>
        <p style="color: #666;">Ajuste sua câmera</p>
    </div>

    <div id="hud-top">
        <div class="hud-panel">
            <div class="label" id="mode-label">MODO</div>
            <div class="value" id="game-status">PARADO</div>
        </div>
        <div class="hud-panel" style="text-align: right;">
            <div class="label">PONTOS</div>
            <div class="value" id="score">0</div>
        </div>
    </div>

    <div id="energy-bar-container">
        <div id="energy-fill"></div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline></video>
    </div>

    <script>
        /**
         * thIAguinho Arcade Engine - Master Gold Version
         * Fusão de Correções Técnicas (Manus) e Lógica de Jogo (Gemini).
         */
        const params = new URLSearchParams(window.location.search);
        const GAME_MODE = params.get('mode') || 'dance';
        
        // Configuração de Gameplay
        let score = 0;
        let playerSpeed = 0; // Velocidade atual (0 a 100)
        let lastShoulderY = 0; // Para detectar corrida
        let gameActive = false;
        
        // Elementos UI
        const uiScore = document.getElementById('score');
        const uiStatus = document.getElementById('game-status');
        const uiEnergy = document.getElementById('energy-fill');
        const uiMode = document.getElementById('mode-label');

        if(GAME_MODE === 'run') uiMode.innerText = "CORRIDA (CORRA NO LUGAR!)";
        if(GAME_MODE === 'dance') uiMode.innerText = "DANÇA (MEXA-SE!)";
        if(GAME_MODE === 'race') uiMode.innerText = "GRAND PRIX (INCLINE-SE!)";

        // ThreeJS Variables
        let scene, camera, renderer, model, floorMesh;
        const clock = new THREE.Clock();
        const ASSETS = {
            mascote: './assets/mascote.glb',
            pista_corrida: './assets/estrada.jpg',
            pista_dance: './assets/pista.jpg'
        };
        
        window.onload = function() {
            initThreeJS();
            initAI();
        };

        // --- MOTOR GRÁFICO ---
        function initThreeJS() {
            scene = new THREE.Scene();
            
            // Iluminação e Ambiente
            if(GAME_MODE === 'dance') {
                scene.background = new THREE.Color(0x100020);
                scene.fog = new THREE.FogExp2(0x100020, 0.04);
            } else {
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 10, 60);
            }

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.5, 3.8); // Câmera na altura dos olhos

            // Renderer com suporte a Intel HD 3000 (Requisito: failIfMajorPerformanceCaveat: false)
            try {
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true, 
                    failIfMajorPerformanceCaveat: false 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true; // Sombras
                document.body.appendChild(renderer.domElement);
            } catch(e) {
                alert("Erro de GPU. Tente no celular.");
            }

            // Luzes
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 1.2);
            dir.position.set(5, 10, 7);
            dir.castShadow = true;
            scene.add(dir);

            // Cenário
            createFloor();

            // Carregar Modelo (Usando a função robusta de Manus)
            loadMascot();

            animate();
        }

        function createFloor() {
            const texLoader = new THREE.TextureLoader();
            
            if(GAME_MODE === 'dance') {
                // Piso Neon Procedural
                const geometry = new THREE.PlaneGeometry(20, 20);
                const material = new THREE.MeshPhongMaterial({ color: 0x222222, specular: 0xff00ff, shininess: 30 });
                floorMesh = new THREE.Mesh(geometry, material);
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.receiveShadow = true;
                
                // Grid Neon
                const grid = new THREE.GridHelper(20, 20, 0x00ffff, 0xff00cc);
                scene.add(grid);
                scene.add(floorMesh);
            } else {
                // Pista de Corrida
                const img = (GAME_MODE === 'race') ? ASSETS.pista_dance : ASSETS.pista_corrida; // Usando assets originais
                texLoader.load(img, (tex) => {
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;
                    tex.repeat.set(1, 10);
                    const mat = new THREE.MeshStandardMaterial({ map: tex });
                    floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 60), mat);
                    floorMesh.rotation.x = -Math.PI / 2;
                    floorMesh.position.z = -20;
                    floorMesh.receiveShadow = true;
                    scene.add(floorMesh);
                });
            }
        }

        function loadMascot() {
            const loader = new THREE.GLTFLoader();
            
            // CONFIGURAÇÃO DRACO (Requisito: Usar o decoder do Google)
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
            loader.setDRACOLoader(dracoLoader);

            // logStatus("Baixando e Descomprimindo Mascote..."); // Removido pois o Gemini usa um loader simples

            loader.load(ASSETS.mascote, (gltf) => {
                model = gltf.scene;
                
                // Processamento de Materiais e Sombras (Requisito: Material Fallback Dourado)
                model.traverse((o) => {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = true;
                        // Fallback Dourado se vier sem textura
                        if (!o.material || !o.material.map) {
                            o.material = new THREE.MeshStandardMaterial({
                                color: 0xFFD700, // Dourado
                                roughness: 0.3,
                                metalness: 0.5
                            });
                        }
                    }
                });

                // Auto-Escala e Centralização (Requisito: 2.5 unidades de altura, centralizado em 0,0,0)
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                
                // Calcula a escala para que a altura (eixo Y) seja 2.5
                const targetHeight = 2.5;
                const scale = targetHeight / size.y;
                model.scale.setScalar(scale);
                
                // Recalcula a BoundingBox após a escala para centralização precisa
                model.updateWorldMatrix(true, true);
                const newBox = new THREE.Box3().setFromObject(model);
                
                // Posição X e Z: Centraliza
                model.position.x -= newBox.getCenter(new THREE.Vector3()).x;
                model.position.z -= newBox.getCenter(new THREE.Vector3()).z;
                
                // Posição Y: Coloca a base em y=0
                model.position.y -= newBox.min.y;
                
                scene.add(model);
                
                // Finaliza Loading
                document.getElementById('loading').style.display = 'none';
                gameActive = true;

            }, (xhr) => {
                // Lógica de progresso removida para simplificar o código do Gemini
            }, (err) => {
                alert("Erro ao carregar 'assets/mascote.glb'. Verifique se o arquivo existe.");
            });
        }

        // --- LÓGICA DE JOGO (GAME LOOP - Baseado no Gemini) ---
        function updateGameplay(results) {
            if(!gameActive || !results.poseLandmarks) return;

            const landmarks = results.poseLandmarks;
            
            // MODO CORRIDA: Detectar "salto" ou corrida no lugar
            if(GAME_MODE === 'run') {
                // Média da altura dos ombros
                const shoulderY = (landmarks[11].y + landmarks[12].y) / 2;
                const delta = Math.abs(shoulderY - lastShoulderY);
                
                // Se houver movimento vertical significativo -> Aumenta velocidade
                if(delta > 0.005) playerSpeed += 2; 
                else playerSpeed *= 0.95; // Desacelera se parar

                lastShoulderY = shoulderY;
            }

            // MODO DANÇA: Detectar energia total (movimento de pulsos)
            if(GAME_MODE === 'dance') {
                // Simplesmente mede o quanto você está se mexendo
                // Nota: A lógica original do Gemini era muito simples. Mantendo a base.
                playerSpeed = 50; // Base
            }

            // MODO RACE: Inclinação lateral
            if(GAME_MODE === 'race') {
                playerSpeed = 80; // Velocidade constante
                // Nariz define a posição X
                const headX = (landmarks[0].x - 0.5) * -10; 
                if(model) model.position.x += (headX - model.position.x) * 0.1;
            }

            // Limites
            playerSpeed = Math.min(Math.max(playerSpeed, 0), 100);
            
            // Atualizar UI (Requisito: gameSpeed controla a altura da barra)
            uiEnergy.style.height = playerSpeed + "%";
            
            if(playerSpeed > 10) {
                uiStatus.innerText = "EM MOVIMENTO";
                uiStatus.style.color = "#00ff00";
                
                // Mover cenário (Requisito: gameSpeed controla offset.y da textura)
                if(floorMesh && floorMesh.material.map) {
                    floorMesh.material.map.offset.y -= (playerSpeed * 0.0005);
                }
                
                // Pontuação
                score += Math.round(playerSpeed / 10);
                uiScore.innerText = score;
            } else {
                uiStatus.innerText = "PARADO";
                uiStatus.style.color = "#ff3333";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(renderer) renderer.render(scene, camera);
        }

        // --- SISTEMA DE IA E RIGGING (MediaPipe + Kalidokit) ---
        function initAI() {
            const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5});
            
            pose.onResults((results) => {
                updateGameplay(results); // Atualiza lógica do jogo

                if (!model || !results.poseLandmarks) return;

                // 2. Resolve Cinemática
                const riggedPose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {
                    runtime: "mediapipe",
                    video: document.getElementById('input_video')
                });

                // 3. Aplica Rotação aos Ossos (Rigging Universal)
                rigCharacter(riggedPose);
            });

            const vid = document.getElementById('input_video');
            const cam = new Camera(vid, {
                onFrame: async () => { await pose.send({image: vid}); },
                width: 640, height: 480
            });
            cam.start();
        }

        function rigCharacter(poseData) {
            // Requisito: Mapeamento universal com slerp (fator 0.5)
            const mapBone = (part, rot) => {
                if (!rot) return;
                
                // Mapeamento Universal: mixamorig:part, mixamorigpart, part
                const bone = model.getObjectByName(`mixamorig:${part}`) || 
                             model.getObjectByName(`mixamorig${part}`) || 
                             model.getObjectByName(part);
                
                if (bone) {
                    // Suavização (Slerp)
                    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x, rot.y, rot.z));
                    bone.quaternion.slerp(q, 0.5); // Fator 0.5 para suavização da IA
                }
            };

            // Mapeamento Full Body
            mapBone("Hips", poseData.Hips);
            mapBone("Spine", poseData.Spine);
            mapBone("Spine1", poseData.Spine1);
            mapBone("Neck", poseData.Neck);
            mapBone("Head", poseData.Head);

            mapBone("LeftArm", poseData.LeftUpperArm);
            mapBone("LeftForeArm", poseData.LeftLowerArm);
            mapBone("LeftHand", poseData.LeftHand);

            mapBone("RightArm", poseData.RightUpperArm);
            mapBone("RightForeArm", poseData.RightLowerArm);
            mapBone("RightHand", poseData.RightHand);

            mapBone("LeftUpLeg", poseData.LeftUpperLeg);
            mapBone("LeftLeg", poseData.LeftLowerLeg);
            mapBone("LeftFoot", poseData.LeftFoot);

            mapBone("RightUpLeg", poseData.RightUpperLeg);
            mapBone("RightLeg", poseData.RightLowerLeg);
            mapBone("RightFoot", poseData.RightFoot);
        }

        // --- AJUSTES FINAIS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>